{"version":3,"sources":["../node_modules/tsup/assets/cjs_shims.js","../src/bin.ts","../src/utils.ts"],"sourcesContent":["// Shim globals in cjs bundle\n// There's a weird bug that esbuild will always inject importMetaUrl\n// if we export it as `const importMetaUrl = ... __filename ...`\n// But using a function will not cause this issue\n\nconst getImportMetaUrl = () =>\n  typeof document === 'undefined'\n    ? new URL(`file:${__filename}`).href\n    : (document.currentScript && document.currentScript.src) ||\n      new URL('main.js', document.baseURI).href\n\nexport const importMetaUrl = /* @__PURE__ */ getImportMetaUrl()\n","#!/usr/bin/env node\n\nimport enquirer from 'enquirer';\nimport fuzzysearch from 'fuzzysearch';\nimport mri from 'mri';\nimport * as fs from 'node:fs/promises';\nimport * as path from 'node:path';\nimport picocolors from 'picocolors';\nimport type { Options } from 'tiged';\nimport { tiged } from 'tiged';\nimport { glob } from 'tinyglobby';\nimport { base, pathExists, tryRequire } from './utils.js';\n\nconst { bold, cyan, magenta, red, underline } = picocolors;\n\nconst args = mri<Options & { help?: string }>(process.argv.slice(2), {\n  alias: {\n    f: 'force',\n    c: 'cache',\n    o: 'offline-mode',\n    D: 'disable-cache',\n    v: 'verbose',\n    m: 'mode',\n    s: 'subgroup',\n    d: 'sub-directory',\n  },\n  boolean: [\n    'force',\n    'cache',\n    'offline-mode',\n    'disable-cache',\n    'verbose',\n    'subgroup',\n  ],\n});\nconst [src, dest = '.'] = args._;\n\n/**\n * The main function of the application.\n * It handles the logic for displaying help,\n * interactive mode, and running the application.\n *\n * @returns A promise that resolves when the main function completes.\n */\nasync function main() {\n  if (args.help) {\n    const help = (\n      await fs.readFile(path.join(__dirname, '..', 'help.md'), 'utf-8')\n    )\n      .replace(/^(\\s*)#+ (.+)/gm, (m, s, _) => s + bold(_))\n      .replace(/_([^_]+)_/g, (m, _) => underline(_))\n      .replace(/`([^`]+)`/g, (m, _) => cyan(_)); //` syntax highlighter fix\n\n    process.stdout.write(`\\n${help}\\n`);\n  } else if (!src) {\n    // interactive mode\n\n    const accessLookup = new Map<string, number>();\n\n    const accessJsonFiles = await glob(`**/access.json`, {\n      cwd: base,\n    });\n\n    await Promise.all(\n      accessJsonFiles.map(async file => {\n        const [host, user, repo] = file.split(path.sep);\n\n        const json = await fs.readFile(`${base}/${file}`, 'utf-8');\n        const logs: Record<string, string> = JSON.parse(json);\n\n        Object.entries(logs).forEach(([ref, timestamp]) => {\n          const id = `${host}:${user}/${repo}#${ref}`;\n          accessLookup.set(id, new Date(timestamp).getTime());\n        });\n      }),\n    );\n\n    const getChoice = (file: string) => {\n      const [host, user, repo] = file.split(path.sep);\n\n      const cacheLogs: Record<string, string> = tryRequire(`${base}/${file}`);\n\n      return Object.entries(cacheLogs).map(([ref, hash]) => ({\n        name: hash,\n        message: `${host}:${user}/${repo}#${ref}`,\n        value: `${host}:${user}/${repo}#${ref}`,\n      }));\n    };\n\n    const choices = (\n      await Promise.all(\n        (await glob(`**/map.json`, { cwd: base })).map(getChoice),\n      )\n    )\n      .reduce(\n        (accumulator, currentValue) => accumulator.concat(currentValue),\n        [],\n      )\n      .sort((a, b) => {\n        const aTime = accessLookup.get(a.value) ?? 0;\n        const bTime = accessLookup.get(b.value) ?? 0;\n\n        return bTime - aTime;\n      });\n\n    const options = await enquirer.prompt<\n      { dest: string; src: string } & Options\n    >([\n      // FIXME: `suggest` is not in the type definition\n      {\n        type: 'autocomplete',\n        name: 'src',\n        message: 'Repo to clone?',\n        suggest: (input: string, choices: { value: string }[]) =>\n          choices.filter(({ value }) => fuzzysearch(input, value)),\n        choices,\n      } as any,\n      {\n        type: 'input',\n        name: 'dest',\n        message: 'Destination directory?',\n        initial: '.',\n      },\n      {\n        type: 'toggle',\n        name: 'cache',\n        message: 'Use cached version?',\n      },\n    ]);\n\n    const empty =\n      !(await pathExists(options.dest)) ||\n      (await fs.readdir(options.dest)).length === 0;\n\n    if (!empty) {\n      const { force } = await enquirer.prompt<Options>([\n        {\n          type: 'toggle',\n          name: 'force',\n          message: 'Overwrite existing files?',\n        },\n      ]);\n\n      if (!force) {\n        console.error(magenta(`! Directory not empty â€” aborting`));\n        return;\n      }\n    }\n\n    await run(options.src, options.dest, {\n      force: true,\n      cache: options.cache,\n    });\n  } else {\n    await run(src, dest, args);\n  }\n}\n\n/**\n * Runs the cloning process from the specified source\n * to the destination directory.\n *\n * @param src - The source repository to clone from.\n * @param dest - The destination directory where the repository will be cloned to.\n * @param args - Additional options for the cloning process.\n */\nasync function run(src: string, dest: string, args: Options) {\n  const t = tiged(src, args);\n\n  t.on('info', event => {\n    console.error(cyan(`> ${event.message?.replace('options.', '--')}`));\n  });\n\n  t.on('warn', event => {\n    console.error(magenta(`! ${event.message?.replace('options.', '--')}`));\n  });\n\n  try {\n    await t.clone(dest);\n  } catch (err) {\n    if (err instanceof Error) {\n      console.error(red(`! ${err.message.replace('options.', '--')}`));\n      process.exit(1);\n    }\n  }\n}\n\nmain();\n","import { HttpsProxyAgent } from 'https-proxy-agent';\nimport * as child_process from 'node:child_process';\nimport { createWriteStream } from 'node:fs';\nimport * as fs from 'node:fs/promises';\nimport * as https from 'node:https';\nimport { createRequire } from 'node:module';\nimport type { constants } from 'node:os';\nimport { homedir, tmpdir } from 'node:os';\nimport * as path from 'node:path';\n\nconst tmpDirName = 'tmp';\n\nexport const tigedConfigName = 'degit.json';\n\nconst getHomeOrTmp = () => homedir() || tmpdir();\n\nconst homeOrTmp = /* @__PURE__ */ getHomeOrTmp();\n\n/**\n * Represents the possible error codes for the Tiged utility.\n */\nexport type TigedErrorCode =\n  | 'DEST_NOT_EMPTY'\n  | 'MISSING_REF'\n  | 'MISSING_GIT'\n  | 'COULD_NOT_DOWNLOAD'\n  | 'BAD_SRC'\n  | 'UNSUPPORTED_HOST'\n  | 'BAD_REF'\n  | 'COULD_NOT_FETCH'\n  | 'NO_FILES'\n  | keyof typeof constants.errno;\n\n/**\n * Represents the options for a Tiged error.\n */\ninterface TigedErrorOptions extends ErrorOptions {\n  /**\n   * The error code associated with the error.\n   */\n  code?: TigedErrorCode;\n\n  /**\n   * The original error that caused this error.\n   */\n  original?: Error;\n\n  /**\n   * The reference (e.g., branch, tag, commit) that was being targeted.\n   */\n  ref?: string;\n\n  /**\n   * The URL associated with the error.\n   */\n  url?: string;\n}\n\n/**\n * Represents an error that occurs during the tiged process.\n *\n * @extends Error\n */\nexport class TigedError extends Error {\n  /**\n   * The error code associated with the error.\n   */\n  declare public code?: TigedErrorOptions['code'];\n\n  /**\n   * The original error that caused this error.\n   */\n  declare public original?: TigedErrorOptions['original'];\n\n  /**\n   * The reference (e.g., branch, tag, commit) that was being targeted.\n   */\n  declare public ref?: TigedErrorOptions['ref'];\n\n  /**\n   * The URL associated with the error.\n   */\n  declare public url?: TigedErrorOptions['url'];\n\n  /**\n   * Creates a new instance of {@linkcode TigedError}.\n   *\n   * @param message - The error message.\n   * @param opts - Additional options for the error.\n   */\n  constructor(message?: string, opts?: TigedErrorOptions) {\n    super(message);\n    Object.assign(this, opts);\n  }\n}\n\n/**\n * Tries to require a module and returns the result.\n * If the module cannot be required, it returns `null`.\n *\n * @param file - The path to the module file.\n * @param opts - Optional options for requiring the module.\n * @param opts.clearCache - If `true`, clears the module cache before requiring the module.\n * @returns The required module or `null` if it cannot be required.\n */\nexport function tryRequire(\n  file: string,\n  opts?: {\n    /**\n     * If `true`, clears the module cache before requiring the module.\n     */\n    clearCache?: true | undefined;\n  },\n) {\n  const require = createRequire(import.meta.url);\n  try {\n    if (opts && opts.clearCache === true) {\n      delete require.cache[require.resolve(file)];\n    }\n    return require(file);\n  } catch (err) {\n    return null;\n  }\n}\n\n/**\n * Executes a command and returns the `stdout` and `stderr` as strings.\n *\n * @param command - The command to execute.\n * @param size - The maximum buffer size in kilobytes (default: 500KB).\n * @returns A promise that resolves to an object containing the `stdout` and `stderr` strings.\n */\nexport async function exec(\n  command: string,\n  size = 500,\n): Promise<{ stdout: string; stderr: string }> {\n  return new Promise<{ stdout: string; stderr: string }>((fulfil, reject) => {\n    child_process.exec(\n      command,\n      { maxBuffer: 1024 * size },\n      (err, stdout, stderr) => {\n        if (err) {\n          reject(err);\n          return;\n        }\n\n        fulfil({ stdout, stderr });\n      },\n    );\n  }).catch(err => {\n    if (err.code === 'ERR_CHILD_PROCESS_STDIO_MAXBUFFER') {\n      return exec(command, size * 2);\n    }\n    return Promise.reject(err);\n  });\n}\n\n/**\n * Fetches a resource from the specified URL\n * and saves it to the destination path.\n * Optionally, a proxy URL can be provided to make the\n * request through a proxy server.\n *\n * @param url - The URL of the resource to fetch.\n * @param dest - The destination path to save the fetched resource.\n * @param proxy - Optional. The URL of the proxy server to use for the request.\n * @returns A promise that resolves when the resource is successfully fetched and saved, or rejects with an error.\n */\nexport async function fetch(url: string, dest: string, proxy?: string) {\n  return new Promise<void>((fulfil, reject) => {\n    const parsedUrl = new URL(url);\n    const options: https.RequestOptions = {\n      hostname: parsedUrl.hostname,\n      port: parsedUrl.port,\n      path: parsedUrl.pathname,\n      headers: {\n        Connection: 'close',\n      },\n    };\n    if (proxy) {\n      options.agent = new HttpsProxyAgent(proxy);\n    }\n\n    https\n      .get(options, response => {\n        const code = response.statusCode;\n        if (code == null) {\n          return reject(new Error('No status code'));\n        }\n        if (code >= 400) {\n          reject({ code, message: response.statusMessage });\n        } else if (code >= 300) {\n          if (response.headers.location == null) {\n            return reject(new Error('No location header'));\n          }\n          fetch(response.headers.location, dest, proxy).then(fulfil, reject);\n        } else {\n          response\n            .pipe(createWriteStream(dest))\n            .on('finish', () => fulfil())\n            .on('error', reject);\n        }\n      })\n      .on('error', reject);\n  });\n}\n\n/**\n * Stashes files from a directory to a temporary directory.\n *\n * @param dir - The source directory containing the files to be stashed.\n * @param dest - The destination directory where the stashed files will be stored.\n * @returns A promise that resolves when the stashing process is complete.\n */\nexport async function stashFiles(dir: string, dest: string) {\n  const tmpDir = path.join(dir, tmpDirName);\n  try {\n    await fs.rm(tmpDir, { recursive: true, force: true });\n  } catch (e) {\n    if (\n      !(e instanceof Error && 'errno' in e && 'syscall' in e && 'code' in e)\n    ) {\n      return;\n    }\n    if (e.errno !== -2 && e.syscall !== 'rmdir' && e.code !== 'ENOENT') {\n      throw e;\n    }\n  }\n  await fs.mkdir(tmpDir);\n  const files = await fs.readdir(dest, { recursive: true });\n  for (const file of files) {\n    const filePath = path.join(dest, file);\n    const targetPath = path.join(tmpDir, file);\n    const isDir = await isDirectory(filePath);\n    if (isDir) {\n      await fs.cp(filePath, targetPath, { recursive: true });\n    } else {\n      await fs.cp(filePath, targetPath);\n      await fs.unlink(filePath);\n    }\n  }\n}\n\n/**\n * Unstashes files from a temporary directory to a destination directory.\n *\n * @param dir - The directory where the temporary directory is located.\n * @param dest - The destination directory where the files will be unstashed.\n */\nexport async function unstashFiles(dir: string, dest: string) {\n  const tmpDir = path.join(dir, tmpDirName);\n  const files = await fs.readdir(tmpDir, { recursive: true });\n  for (const filename of files) {\n    const tmpFile = path.join(tmpDir, filename);\n    const targetPath = path.join(dest, filename);\n    const isDir = await isDirectory(tmpFile);\n    if (isDir) {\n      await fs.cp(tmpFile, targetPath, { recursive: true });\n    } else {\n      if (filename !== tigedConfigName) {\n        await fs.cp(tmpFile, targetPath);\n      }\n      await fs.unlink(tmpFile);\n    }\n  }\n  await fs.rm(tmpDir, { recursive: true, force: true });\n}\n\n/**\n * Asynchronously checks if a given file path exists.\n *\n * @param filePath - The path to the file or directory to check.\n * @returns A promise that resolves to `true` if the path exists, otherwise `false`.\n *\n * @example\n * <caption>#### Check if a file exists</caption>\n *\n * ```ts\n * const exists = await pathExists('/path/to/file');\n * console.log(exists); // true or false\n * ```\n */\nexport const pathExists = async (filePath: string): Promise<boolean> => {\n  try {\n    await fs.access(filePath);\n    return true;\n  } catch (err) {\n    return false;\n  }\n};\n\n/**\n * Asynchronously checks if a given file path is a directory.\n *\n * @param filePath - The path to the file or directory to check.\n * @returns A promise that resolves to `true` if the path is a directory, otherwise `false`.\n *\n * @example\n * <caption>#### Check if a path is a directory</caption>\n *\n * ```ts\n * const isDir = await isDirectory('/path/to/directory');\n * console.log(isDir); // true or false\n * ```\n */\nexport const isDirectory = async (filePath: string): Promise<boolean> => {\n  try {\n    const stats = await fs.lstat(filePath);\n    return stats.isDirectory();\n  } catch (err) {\n    return false;\n  }\n};\n\nexport const base = /* @__PURE__ */ path.join(homeOrTmp, '.degit');\n"],"mappings":"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","names":["getImportMetaUrl","importMetaUrl","import_enquirer","import_fuzzysearch","import_mri","fs","path","import_picocolors","import_tiged","import_tinyglobby","import_https_proxy_agent","fs","import_node_module","import_node_os","path","getHomeOrTmp","homeOrTmp","tryRequire","file","opts","require","importMetaUrl","pathExists","filePath","base","homeOrTmp","bold","cyan","magenta","red","underline","picocolors","args","mri","src","dest","main","help","m","s","_","run","accessLookup","accessJsonFiles","base","file","host","user","repo","json","logs","ref","timestamp","id","getChoice","cacheLogs","tryRequire","hash","choices","accumulator","currentValue","a","b","aTime","options","enquirer","input","value","fuzzysearch","pathExists","force","t","event","err"]}