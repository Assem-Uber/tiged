{"version":3,"sources":["../src/index.ts","../node_modules/tsup/assets/cjs_shims.js","../src/utils.ts"],"sourcesContent":["import { execSync } from 'node:child_process';\nimport { EventEmitter } from 'node:events';\nimport * as fs from 'node:fs/promises';\nimport * as path from 'node:path';\nimport picocolors from 'picocolors';\nimport { extract } from 'tar';\nimport {\n  TigedError,\n  base,\n  exec,\n  fetch,\n  isDirectory,\n  pathExists,\n  stashFiles,\n  tigedConfigName,\n  tryRequire,\n  unstashFiles,\n} from './utils.js';\n\nconst { bold, cyan, magenta, red } = picocolors;\n\nconst validModes = new Set<ValidModes>(['tar', 'git']);\n\n/**\n * Represents the valid modes for a file.\n * The modes can be either `'tar'` or `'git'`.\n */\ntype ValidModes = 'tar' | 'git';\n\n/**\n * Represents the options for a specific operation.\n */\nexport interface Options {\n  /**\n   * Specifies whether to use caching.\n   *\n   * @default false\n   */\n  cache?: boolean;\n\n  /**\n   * Forces the operation to proceed, despite non-empty destination directory\n   * potentially overwriting existing files.\n   *\n   * @default false\n   */\n  force?: boolean;\n\n  /**\n   * Specifies the mode for the operation.\n   *\n   * @default undefined\n   */\n  mode?: ValidModes;\n\n  /**\n   * Specifies whether to enable verbose logging.\n   *\n   * @default false\n   */\n  verbose?: boolean;\n\n  /**\n   * Specifies whether to enable offline mode.\n   *\n   * @default false\n   */\n  'offline-mode'?: boolean;\n\n  /**\n   * Specifies whether to enable offline mode.\n   *\n   * @default false\n   */\n  offlineMode?: boolean;\n\n  /**\n   * Specifies whether to disable caching.\n   *\n   * @default false\n   */\n  'disable-cache'?: boolean;\n\n  /**\n   * Specifies whether to disable caching.\n   *\n   * @default false\n   */\n  disableCache?: boolean;\n\n  /**\n   * Specifies whether to use subgrouping.\n   *\n   * @default false\n   */\n  subgroup?: boolean;\n\n  /**\n   * Specifies the sub-directory for the operation.\n   *\n   * @default undefined\n   */\n  'sub-directory'?: string;\n}\n\n// TODO: We might not need this one.\n/**\n * Represents the possible information codes.\n */\ntype InfoCode =\n  | 'SUCCESS'\n  | 'FILE_DOES_NOT_EXIST'\n  | 'REMOVED'\n  | 'DEST_NOT_EMPTY'\n  | 'DEST_IS_EMPTY'\n  | 'USING_CACHE'\n  | 'FOUND_MATCH'\n  | 'FILE_EXISTS'\n  | 'PROXY'\n  | 'DOWNLOADING'\n  | 'EXTRACTING';\n\n/**\n * Represents information about a specific entity.\n */\ninterface Info {\n  /**\n   * The code associated with the entity.\n   */\n  readonly code?: string;\n\n  /**\n   * The message associated with the entity.\n   */\n  readonly message?: string;\n\n  /**\n   * The repository associated with the entity.\n   */\n  readonly repo?: Repo;\n\n  /**\n   * The destination of the entity.\n   */\n  readonly dest?: string;\n}\n\n/**\n * Represents an action.\n */\ninterface Action {\n  /**\n   * The type of action.\n   */\n  action: string;\n\n  /**\n   * The cache option.\n   */\n  cache?: boolean | undefined;\n\n  /**\n   * The verbose option.\n   */\n  verbose?: boolean | undefined;\n}\n\n/**\n * Represents a Tiged action for cloning.\n */\ninterface TigedAction extends Action {\n  /**\n   * The type of action, which is always `'clone'`.\n   */\n  action: 'clone';\n\n  /**\n   * The source path to clone from.\n   */\n  src: string;\n}\n\n/**\n * Represents a remove action.\n */\ninterface RemoveAction extends Action {\n  /**\n   * The type of action, which is always `'remove'`.\n   */\n  action: 'remove';\n\n  /**\n   * An array of file paths to be removed.\n   */\n  files: string[];\n}\n\n/**\n * Creates a new instance of the {@linkcode Tiged} class with\n * the specified source and options.\n *\n * @param src - The source path to clone from.\n * @param opts - The optional configuration options.\n * @returns A new instance of the {@linkcode Tiged} class.\n */\nexport function tiged(src: string, opts?: Options) {\n  return new Tiged(src, opts);\n}\n\n/**\n * The {@linkcode Tiged} class is an event emitter\n * that represents the Tiged tool.\n * It is designed for cloning repositories with specific options,\n * handling caching, proxy settings, and more.\n *\n * @extends EventEmitter\n */\nclass Tiged extends EventEmitter {\n  /**\n   * Enables offline mode, where operations rely on cached data.\n   */\n  declare public offlineMode?: boolean;\n\n  /**\n   * Disables the use of cache for operations,\n   * ensuring data is always fetched anew.\n   */\n  declare public noCache?: boolean;\n\n  /**\n   * Enables caching of data for future operations.\n   * @deprecated Will be removed in v3.X\n   */\n  declare public cache?: boolean;\n\n  /**\n   * Forces the operation to proceed, despite non-empty destination directory\n   * potentially overwriting existing files.\n   */\n  declare public force?: boolean;\n\n  /**\n   * Enables verbose output for more detailed logging information.\n   */\n  declare public verbose?: boolean;\n\n  /**\n   * Specifies the proxy server to be used for network requests.\n   */\n  declare public proxy?: string;\n\n  /**\n   * Indicates if the repository is a subgroup, affecting repository parsing.\n   */\n  declare public subgroup?: boolean;\n\n  /**\n   * Specifies a subdirectory within the repository to focus on.\n   */\n  declare public subdir?: string;\n\n  /**\n   * Holds the parsed repository information.\n   */\n  declare public repo: Repo;\n\n  /**\n   * Indicates the mode of operation,\n   * which determines how the repository is cloned.\n   * Valid modes are `'tar'` and `'git'`.\n   */\n  declare public mode: ValidModes;\n\n  /**\n   * Flags whether stash operations have been performed to avoid duplication.\n   */\n  declare public _hasStashed: boolean;\n\n  /**\n   * Defines actions for directives such as\n   * cloning and removing files or directories.\n   */\n  declare public directiveActions: {\n    clone: (dir: string, dest: string, action: TigedAction) => Promise<void>;\n    remove: (dir: string, dest: string, action: RemoveAction) => Promise<void>;\n  };\n\n  declare public on: (\n    event: 'info' | 'warn',\n    callback: (info: Info) => void,\n  ) => this;\n\n  /**\n   * Constructs a new {@linkcode Tiged} instance\n   * with the specified source and options.\n   *\n   * @param src - The source repository string.\n   * @param opts - Optional parameters to customize the behavior.\n   */\n  constructor(\n    public src: string,\n    opts: Options = {},\n  ) {\n    super();\n    if (opts['offline-mode']) this.offlineMode = opts['offline-mode'];\n    if (opts.offlineMode) this.offlineMode = opts.offlineMode;\n    if (opts['disable-cache']) this.noCache = opts['disable-cache'];\n    if (opts.disableCache) this.noCache = opts.disableCache;\n    // Left cache for backward compatibility. Deprecated. Remove in next major version.\n    this.cache = opts.cache;\n    this.force = opts.force;\n    this.verbose = opts.verbose;\n    this.proxy = this._getHttpsProxy(); // TODO allow setting via --proxy\n    this.subgroup = opts.subgroup;\n    this.subdir = opts['sub-directory'];\n\n    this.repo = parse(src);\n    if (this.subgroup) {\n      this.repo.subgroup = true;\n      this.repo.name = this.repo.subdir?.slice(1) ?? '';\n      this.repo.url += this.repo.subdir;\n      this.repo.ssh = `${this.repo.ssh + this.repo.subdir}.git`;\n      this.repo.subdir = null;\n      if (this.subdir) {\n        this.repo.subdir = this.subdir.startsWith('/')\n          ? this.subdir\n          : `/${this.subdir}`;\n      }\n    }\n    this.mode = opts.mode || this.repo.mode;\n\n    if (!validModes.has(this.mode)) {\n      throw new Error(`Valid modes are ${Array.from(validModes).join(', ')}`);\n    }\n\n    this._hasStashed = false;\n\n    this.directiveActions = {\n      clone: async (dir, dest, action) => {\n        if (this._hasStashed === false) {\n          await stashFiles(dir, dest);\n          this._hasStashed = true;\n        }\n        const opts = Object.assign(\n          { force: true },\n          { cache: action.cache, verbose: action.verbose },\n        );\n        const t = tiged(action.src, opts);\n\n        t.on('info', event => {\n          console.error(cyan(`> ${event.message?.replace('options.', '--')}`));\n        });\n\n        t.on('warn', event => {\n          console.error(\n            magenta(`! ${event.message?.replace('options.', '--')}`),\n          );\n        });\n\n        try {\n          await t.clone(dest);\n        } catch (err) {\n          if (err instanceof Error) {\n            console.error(red(`! ${err.message}`));\n            process.exit(1);\n          }\n        }\n      },\n      remove: this.remove.bind(this),\n    };\n  }\n\n  // Return the HTTPS proxy address. Try to get the value by environment\n  // variable `https_proxy` or `HTTPS_PROXY`.\n  //\n  // TODO allow setting via --proxy\n  /**\n   * Retrieves the HTTPS proxy from the environment variables.\n   *\n   * @returns The HTTPS proxy value, or `undefined` if not found.\n   */\n  public _getHttpsProxy() {\n    const result = process.env.https_proxy;\n    if (!result) {\n      return process.env.HTTPS_PROXY;\n    }\n    return result;\n  }\n\n  /**\n   * Retrieves the directives from the specified destination.\n   *\n   * @param dest - The destination path.\n   * @returns An array of {@linkcode TigedAction} directives, or `false` if no directives are found.\n   */\n  public async _getDirectives(dest: string) {\n    const directivesPath = path.resolve(dest, tigedConfigName);\n    const directives: TigedAction[] | false =\n      tryRequire(directivesPath, { clearCache: true }) || false;\n    if (directives) {\n      await fs.unlink(directivesPath);\n    }\n\n    return directives;\n  }\n\n  /**\n   * Clones the repository to the specified destination.\n   *\n   * @param dest - The destination directory where the repository will be cloned.\n   */\n  public async clone(dest: string) {\n    try {\n      execSync('git --version', { stdio: 'ignore' });\n    } catch (e) {\n      throw new TigedError(\n        'could not find git. Make the directory of your git executable is found in your PATH environment variable.',\n        {\n          code: 'MISSING_GIT',\n        },\n      );\n    }\n\n    await this._checkDirIsEmpty(dest);\n    const { repo } = this;\n    const dir = path.join(base, repo.site, repo.user, repo.name);\n\n    if (this.mode === 'tar') {\n      await this._cloneWithTar(dir, dest);\n    } else {\n      await this._cloneWithGit(dir, dest);\n    }\n\n    this._info({\n      code: 'SUCCESS',\n      message: `cloned ${bold(`${repo.user}/${repo.name}`)}#${bold(repo.ref)}${\n        dest !== '.' ? ` to ${dest}` : ''\n      }`,\n      repo,\n      dest,\n    });\n    const directives = await this._getDirectives(dest);\n    if (directives) {\n      for (const d of directives) {\n        // TODO, can this be a loop with an index to pass for better error messages?\n        await this.directiveActions[d.action](dir, dest, d);\n      }\n      if (this._hasStashed === true) {\n        await unstashFiles(dir, dest);\n      }\n    }\n  }\n\n  /**\n   * Removes files or directories from a specified destination\n   * based on the provided action.\n   *\n   * @param _dir - The directory path.\n   * @param dest - The destination path.\n   * @param action - The action object containing the files to be removed.\n   */\n  public async remove(_dir: string, dest: string, action: RemoveAction) {\n    let { files } = action;\n    if (!Array.isArray(files)) {\n      files = [files];\n    }\n\n    const removedFiles: string[] = [];\n\n    for (const file of files) {\n      const filePath = path.resolve(dest, file);\n      if (await pathExists(filePath)) {\n        const isDir = await isDirectory(filePath);\n        if (isDir) {\n          await fs.rm(filePath, { recursive: true, force: true });\n          removedFiles.push(`${file}/`);\n        } else {\n          await fs.unlink(filePath);\n          removedFiles.push(file);\n        }\n      } else {\n        this._warn({\n          code: 'FILE_DOES_NOT_EXIST',\n          message: `action wants to remove ${bold(file)} but it does not exist`,\n        });\n      }\n    }\n\n    if (removedFiles.length > 0) {\n      this._info({\n        code: 'REMOVED',\n        message: `removed: ${bold(removedFiles.map(d => bold(d)).join(', '))}`,\n      });\n    }\n  }\n\n  /**\n   * Checks if a directory is empty.\n   *\n   * @param dir - The directory path to check.\n   */\n  public async _checkDirIsEmpty(dir: string) {\n    try {\n      const files = await fs.readdir(dir);\n      if (files.length > 0) {\n        if (this.force) {\n          this._info({\n            code: 'DEST_NOT_EMPTY',\n            message: `destination directory is not empty. Using options.force, continuing`,\n          });\n\n          await fs.rm(dir, { recursive: true, force: true });\n        } else {\n          throw new TigedError(\n            `destination directory is not empty, aborting. Use options.force to override`,\n            {\n              code: 'DEST_NOT_EMPTY',\n            },\n          );\n        }\n      } else {\n        this._verbose({\n          code: 'DEST_IS_EMPTY',\n          message: `destination directory is empty`,\n        });\n      }\n    } catch (err) {\n      if (err instanceof TigedError && err.code !== 'ENOENT') throw err;\n    }\n  }\n\n  /**\n   * Emits an `'info'` event with the provided information.\n   *\n   * @param info - The information to be emitted.\n   */\n  public _info(info: Info) {\n    this.emit('info', info);\n  }\n\n  /**\n   * Emits a `'warn'` event with the provided info.\n   *\n   * @param info - The information to be emitted.\n   */\n  public _warn(info: Info) {\n    this.emit('warn', info);\n  }\n\n  /**\n   * Logs the provided {@linkcode info} object\n   * if the {@linkcode verbose} flag is set to `true`.\n   *\n   * @param info - The information to be logged.\n   */\n  public _verbose(info: Info) {\n    if (this.verbose) this._info(info);\n  }\n\n  /**\n   * Retrieves the hash for a given repository.\n   *\n   * @param repo - The repository object.\n   * @param cached - The cached records.\n   * @returns The hash value.\n   */\n  public async _getHash(repo: Repo, cached: Record<string, string>) {\n    try {\n      const refs = await fetchRefs(repo);\n\n      if (refs == null) {\n        return;\n      }\n\n      if (repo.ref === 'HEAD') {\n        return refs?.find(ref => ref.type === 'HEAD')?.hash ?? '';\n      }\n\n      const selectedRef = this._selectRef(refs, repo.ref);\n      if (selectedRef) {\n        return selectedRef;\n      }\n\n      const isCommitHash = /^[0-9a-f]{40}$/.test(repo.ref);\n      if (isCommitHash) {\n        return repo.ref;\n      }\n\n      return;\n    } catch (err) {\n      if (err instanceof TigedError && 'code' in err && 'message' in err) {\n        this._warn(err);\n\n        if (err.original != null) {\n          this._verbose(err.original);\n        }\n      }\n\n      return;\n    }\n  }\n\n  /**\n   * Retrieves the commit hash from the cache for the given repository.\n   *\n   * @param repo - The repository object.\n   * @param cached - The cached commit hashes.\n   * @returns The commit hash if found in the cache; otherwise, `undefined`.\n   */\n  public _getHashFromCache(repo: Repo, cached: Record<string, string>) {\n    if (!(repo.ref in cached)) {\n      return;\n    }\n\n    const hash = cached[repo.ref];\n\n    this._info({\n      code: 'USING_CACHE',\n      message: `using cached commit hash ${hash}`,\n    });\n\n    return hash;\n  }\n\n  /**\n   * Selects a commit hash from an array of references\n   * based on a given selector.\n   *\n   * @param refs - An array of references containing type, name, and hash.\n   * @param selector - The selector used to match the desired reference.\n   * @returns The commit hash that matches the selector, or `null` if no match is found.\n   */\n  public _selectRef(\n    refs: { type: string; name?: string; hash: string }[],\n    selector: string,\n  ) {\n    for (const ref of refs) {\n      if (ref.name === selector) {\n        this._verbose({\n          code: 'FOUND_MATCH',\n          message: `found matching commit hash: ${ref.hash}`,\n        });\n        return ref.hash;\n      }\n    }\n\n    if (selector.length < 8) return null;\n\n    for (const ref of refs) {\n      if (ref.hash.startsWith(selector)) return ref.hash;\n    }\n\n    return;\n  }\n\n  /**\n   * Clones the repository specified by {@linkcode repo}\n   * into the {@linkcode dest} directory using a tarball.\n   *\n   * @param dir - The directory where the repository is cloned.\n   * @param dest - The destination directory where the repository will be extracted.\n   * @throws A {@linkcode TigedError} If the commit hash for the repository reference cannot be found.\n   * @throws A {@linkcode TigedError} If the tarball cannot be downloaded.\n   * @returns A promise that resolves when the cloning and extraction process is complete.\n   */\n  public async _cloneWithTar(dir: string, dest: string) {\n    const { repo } = this;\n\n    const cached: Record<string, string> =\n      tryRequire(path.join(dir, 'map.json')) || {};\n    const hash =\n      this.offlineMode || this.cache\n        ? this._getHashFromCache(repo, cached)\n        : await this._getHash(repo, cached);\n\n    const subdir = repo.subdir ? `${repo.name}-${hash}${repo.subdir}` : null;\n\n    if (!hash) {\n      // TODO 'did you mean...?'\n      throw new TigedError(`could not find commit hash for ${repo.ref}`, {\n        code: 'MISSING_REF',\n        ref: repo.ref,\n      });\n    }\n\n    const file = `${dir}/${hash}.tar.gz`;\n    const url =\n      repo.site === 'gitlab'\n        ? `${repo.url}/-/archive/${hash}/${repo.name}-${hash}.tar.gz`\n        : repo.site === 'bitbucket'\n          ? `${repo.url}/get/${hash}.tar.gz`\n          : `${repo.url}/archive/${hash}.tar.gz`;\n\n    try {\n      if (!this.offlineMode || !this.cache) {\n        try {\n          if (this.noCache) {\n            this._verbose({\n              code: 'NO_CACHE',\n              message: `Not using cache. noCache set to true.`,\n            });\n            throw \"don't use cache\";\n          }\n          await fs.stat(file);\n          this._verbose({\n            code: 'FILE_EXISTS',\n            message: `${file} already exists locally`,\n          });\n        } catch (err) {\n          // Not getting file from cache. Either because there is no cached tar or because option no cache is set to true.\n          await fs.mkdir(path.dirname(file), { recursive: true });\n\n          if (this.proxy) {\n            this._verbose({\n              code: 'PROXY',\n              message: `using proxy ${this.proxy}`,\n            });\n          }\n\n          this._verbose({\n            code: 'DOWNLOADING',\n            message: `downloading ${url} to ${file}`,\n          });\n\n          await fetch(url, file, this.proxy);\n        }\n      }\n    } catch (err) {\n      if (err instanceof Error) {\n        throw new TigedError(`could not download ${url}`, {\n          code: 'COULD_NOT_DOWNLOAD',\n          url,\n          original: err,\n        });\n      }\n    }\n\n    if (!this.noCache) await updateCache(dir, repo, hash, cached);\n\n    this._verbose({\n      code: 'EXTRACTING',\n      message: `extracting ${\n        subdir ? `${repo.subdir} from ` : ''\n      }${file} to ${dest}`,\n    });\n\n    await fs.mkdir(dest, { recursive: true });\n    const extractedFiles = untar(file, dest, subdir);\n    if (extractedFiles.length === 0) {\n      const noFilesErrorMessage: string = subdir\n        ? 'No files to extract. Make sure you typed in the subdirectory name correctly.'\n        : 'No files to extract. The tar file seems to be empty';\n      throw new TigedError(noFilesErrorMessage, {\n        code: 'NO_FILES',\n      });\n    }\n    if (this.noCache) {\n      await fs.rm(file);\n    }\n  }\n\n  /**\n   * Clones the repository using Git.\n   *\n   * @param _dir - The source directory.\n   * @param dest - The destination directory.\n   */\n  public async _cloneWithGit(_dir: string, dest: string) {\n    let gitPath = /https:\\/\\//.test(this.repo.src)\n      ? this.repo.url\n      : this.repo.ssh;\n    gitPath = this.repo.site === 'huggingface' ? this.repo.url : gitPath;\n    const isWin = process.platform === 'win32';\n    if (this.repo.subdir) {\n      await fs.mkdir(path.join(dest, '.tiged'), { recursive: true });\n      const tempDir = path.join(dest, '.tiged');\n      if (isWin) {\n        await exec(\n          `cd ${tempDir} && git init && git remote add origin ${gitPath} && git fetch --depth 1 origin ${this.repo.ref} && git checkout FETCH_HEAD`,\n        );\n      } else if (this.repo.ref && this.repo.ref !== 'HEAD' && !isWin) {\n        await exec(\n          `cd ${tempDir}; git init; git remote add origin ${gitPath}; git fetch --depth 1 origin ${this.repo.ref}; git checkout FETCH_HEAD`,\n        );\n      } else {\n        await exec(`git clone --depth 1 ${gitPath} ${tempDir}`);\n      }\n      const files = await fs.readdir(`${tempDir}${this.repo.subdir}`, {\n        recursive: true,\n      });\n      await Promise.all(\n        files.map(async file => {\n          return fs.rename(\n            `${tempDir}${this.repo.subdir}/${file}`,\n            `${dest}/${file}`,\n          );\n        }),\n      );\n      await fs.rm(tempDir, { recursive: true, force: true });\n    } else {\n      if (isWin) {\n        await fs.mkdir(dest, { recursive: true });\n        await exec(\n          `cd ${dest} && git init && git remote add origin ${gitPath} && git fetch --depth 1 origin ${this.repo.ref} && git checkout FETCH_HEAD`,\n        );\n      } else if (this.repo.ref && this.repo.ref !== 'HEAD' && !isWin) {\n        await fs.mkdir(dest, { recursive: true });\n        await exec(\n          `cd ${dest}; git init; git remote add origin ${gitPath}; git fetch --depth 1 origin ${this.repo.ref}; git checkout FETCH_HEAD`,\n        );\n      } else {\n        await exec(`git clone --depth 1 ${gitPath} ${dest}`);\n      }\n      await fs.rm(path.resolve(dest, '.git'), { recursive: true, force: true });\n    }\n  }\n}\n\nconst supported: Record<string, string> = {\n  github: '.com',\n  gitlab: '.com',\n  bitbucket: '.com',\n  'git.sr.ht': '.ht',\n  huggingface: '.co',\n  codeberg: '.org',\n};\n\n/**\n * Represents a repository.\n */\nexport interface Repo {\n  /**\n   * The hosting service or site for the repository.\n   */\n  site: string;\n\n  /**\n   * The username or organization under which the repository is located.\n   */\n  user: string;\n\n  /**\n   * The name of the repository.\n   */\n  name: string;\n\n  /**\n   * The reference to a specific branch, commit, or tag in the repository.\n   */\n  ref: string;\n\n  /**\n   * The URL to access the repository via HTTP or HTTPS.\n   */\n  url: string;\n\n  /**\n   * The SSH URL to access the repository for Git operations.\n   */\n  ssh: string;\n\n  /**\n   * Optional. A specific subdirectory within the repository to work with,\n   * if applicable. Can be `null` if not used.\n   */\n  subdir?: string | null;\n\n  /**\n   * The mode of operation or interaction with the repository.\n   * Valid modes are `'tar'` and `'git'`.\n   */\n  mode: ValidModes;\n\n  /**\n   * The source URL or path for cloning the repository.\n   */\n  src: string;\n\n  /**\n   * Optional. Indicates whether the repository belongs to a subgroup,\n   * if supported by the hosting service.\n   */\n  subgroup?: boolean;\n}\n\n/**\n * Parses the source URL and returns a {@linkcode Repo} object\n * containing the parsed information.\n *\n * @param src - The source URL to parse.\n * @returns A {@linkcode Repo} object containing the parsed information.\n * @throws A {@linkcode TigedError} If the source URL cannot be parsed.\n */\nfunction parse(src: string): Repo {\n  const match =\n    /^(?:(?:https:\\/\\/)?([^:/]+\\.[^:/]+)\\/|git@([^:/]+)[:/]|([^/]+):)?([^/\\s]+)\\/([^/\\s#]+)(?:((?:\\/[^/\\s#]+)+))?(?:\\/)?(?:#(.+))?/.exec(\n      src,\n    );\n\n  if (!match) {\n    throw new TigedError(`could not parse ${src}`, {\n      code: 'BAD_SRC',\n      url: src,\n    });\n  }\n\n  const site = match[1] || match[2] || match[3] || 'github.com';\n  const tldMatch = /\\.([a-z]{2,})$/.exec(site);\n  const tld = tldMatch ? tldMatch[0] : null;\n  const siteName = tld ? site.replace(new RegExp(`${tld}$`), '') : site;\n\n  const user = match[4] ?? '';\n  const name = match[5]?.replace(/\\.git$/, '') ?? '';\n  const subdir = match[6];\n  const ref = match[7] || 'HEAD';\n\n  const domain = `${siteName}${\n    tld || supported[siteName] || supported[site] || ''\n  }`;\n\n  const url = `https://${domain}/${user}/${name}`;\n  const ssh = `git@${domain}:${user}/${name}`;\n\n  const mode =\n    siteName === 'huggingface'\n      ? 'git'\n      : supported[siteName] || supported[site]\n        ? 'tar'\n        : 'git';\n\n  return { site: siteName, user, name, ref, url, ssh, subdir, mode, src };\n}\n\n/**\n * Extracts the contents of a tar file to a specified destination.\n *\n * @param file - The path to the tar file.\n * @param dest - The destination directory where the contents will be extracted.\n * @param subdir - Optional subdirectory within the tar file to extract. Defaults to null.\n * @returns A list of extracted files.\n */\nfunction untar(file: string, dest: string, subdir: Repo['subdir'] = null) {\n  const extractedFiles: string[] = [];\n  extract(\n    {\n      file,\n      strip: subdir ? subdir.split('/').length : 1,\n      C: dest,\n      sync: true,\n      onReadEntry: entry => {\n        extractedFiles.push(entry.path);\n      },\n    },\n    subdir ? [subdir] : [],\n  );\n  return extractedFiles;\n}\n\n/**\n * Fetches the references (branches, tags, etc.) from a remote Git repository.\n *\n * @param repo - The repository object containing the URL of the remote repository.\n * @returns An array of objects representing the fetched references, each containing the type, name, and hash.\n * @throws A {@linkcode TigedError} If there is an error fetching the remote repository.\n */\nasync function fetchRefs(repo: Repo) {\n  try {\n    const { stdout } = await exec(`git ls-remote ${repo.url} ${repo.ref}`);\n\n    return stdout\n      .trim()\n      .split('\\n')\n      .filter(Boolean)\n      .map(row => {\n        const [hash = '', ref = ''] = row.split('\\t');\n\n        if (ref === 'HEAD') {\n          return {\n            name: hash,\n            type: ref,\n            hash,\n          };\n        }\n\n        const match = /refs\\/(\\w+)\\/(.+)/.exec(ref);\n\n        if (!match)\n          throw new TigedError(`could not parse ${ref}`, {\n            code: 'BAD_REF',\n            ref,\n            url: repo.url,\n          });\n\n        const type =\n          match[1] === 'heads'\n            ? 'branch'\n            : match[1] === 'refs'\n              ? 'ref'\n              : (match[1] ?? '');\n\n        const name = match[2] ?? '';\n\n        return { type, name, hash };\n      });\n  } catch (error) {\n    throw new TigedError(`could not fetch remote ${repo.url}`, {\n      code: 'COULD_NOT_FETCH',\n      url: repo.url,\n      original: error instanceof Error ? error : undefined,\n      ref: repo.ref,\n    });\n  }\n}\n\n/**\n * Updates the cache with the given repository information.\n *\n * @param dir - The directory path where the cache is located.\n * @param repo - The repository object containing the reference and other details.\n * @param hash - The hash value of the repository.\n * @param cached - The cached records.\n * @returns A Promise that resolves when the cache is updated.\n */\nasync function updateCache(\n  dir: string,\n  repo: Repo,\n  hash: string,\n  cached: Record<string, string>,\n) {\n  // update access logs\n  const logs: Record<string, string> =\n    tryRequire(path.join(dir, 'access.json')) || {};\n  logs[repo.ref] = new Date().toISOString();\n  await fs.writeFile(\n    path.join(dir, 'access.json'),\n    JSON.stringify(logs, null, '  '),\n  );\n\n  if (cached[repo.ref] === hash) return;\n\n  const oldHash = cached[repo.ref];\n  if (oldHash) {\n    let used = false;\n    for (const key in cached) {\n      if (cached[key] === hash) {\n        used = true;\n        break;\n      }\n    }\n\n    if (!used) {\n      // we no longer need this tar file\n      try {\n        await fs.unlink(path.join(dir, `${oldHash}.tar.gz`));\n      } catch (err) {\n        // ignore\n      }\n    }\n  }\n\n  cached[repo.ref] = hash;\n  await fs.writeFile(\n    path.join(dir, 'map.json'),\n    JSON.stringify(cached, null, '  '),\n  );\n}\n","// Shim globals in cjs bundle\n// There's a weird bug that esbuild will always inject importMetaUrl\n// if we export it as `const importMetaUrl = ... __filename ...`\n// But using a function will not cause this issue\n\nconst getImportMetaUrl = () =>\n  typeof document === 'undefined'\n    ? new URL(`file:${__filename}`).href\n    : (document.currentScript && document.currentScript.src) ||\n      new URL('main.js', document.baseURI).href\n\nexport const importMetaUrl = /* @__PURE__ */ getImportMetaUrl()\n","import { HttpsProxyAgent } from 'https-proxy-agent';\nimport * as child_process from 'node:child_process';\nimport { createWriteStream } from 'node:fs';\nimport * as fs from 'node:fs/promises';\nimport * as https from 'node:https';\nimport { createRequire } from 'node:module';\nimport type { constants } from 'node:os';\nimport { homedir, tmpdir } from 'node:os';\nimport * as path from 'node:path';\n\nconst tmpDirName = 'tmp';\n\nexport const tigedConfigName = 'degit.json';\n\nconst getHomeOrTmp = () => homedir() || tmpdir();\n\nconst homeOrTmp = /* @__PURE__ */ getHomeOrTmp();\n\n/**\n * Represents the possible error codes for the Tiged utility.\n */\nexport type TigedErrorCode =\n  | 'DEST_NOT_EMPTY'\n  | 'MISSING_REF'\n  | 'MISSING_GIT'\n  | 'COULD_NOT_DOWNLOAD'\n  | 'BAD_SRC'\n  | 'UNSUPPORTED_HOST'\n  | 'BAD_REF'\n  | 'COULD_NOT_FETCH'\n  | 'NO_FILES'\n  | keyof typeof constants.errno;\n\n/**\n * Represents the options for a Tiged error.\n */\ninterface TigedErrorOptions extends ErrorOptions {\n  /**\n   * The error code associated with the error.\n   */\n  code?: TigedErrorCode;\n\n  /**\n   * The original error that caused this error.\n   */\n  original?: Error;\n\n  /**\n   * The reference (e.g., branch, tag, commit) that was being targeted.\n   */\n  ref?: string;\n\n  /**\n   * The URL associated with the error.\n   */\n  url?: string;\n}\n\n/**\n * Represents an error that occurs during the tiged process.\n *\n * @extends Error\n */\nexport class TigedError extends Error {\n  /**\n   * The error code associated with the error.\n   */\n  declare public code?: TigedErrorOptions['code'];\n\n  /**\n   * The original error that caused this error.\n   */\n  declare public original?: TigedErrorOptions['original'];\n\n  /**\n   * The reference (e.g., branch, tag, commit) that was being targeted.\n   */\n  declare public ref?: TigedErrorOptions['ref'];\n\n  /**\n   * The URL associated with the error.\n   */\n  declare public url?: TigedErrorOptions['url'];\n\n  /**\n   * Creates a new instance of {@linkcode TigedError}.\n   *\n   * @param message - The error message.\n   * @param opts - Additional options for the error.\n   */\n  constructor(message?: string, opts?: TigedErrorOptions) {\n    super(message);\n    Object.assign(this, opts);\n  }\n}\n\n/**\n * Tries to require a module and returns the result.\n * If the module cannot be required, it returns `null`.\n *\n * @param file - The path to the module file.\n * @param opts - Optional options for requiring the module.\n * @param opts.clearCache - If `true`, clears the module cache before requiring the module.\n * @returns The required module or `null` if it cannot be required.\n */\nexport function tryRequire(\n  file: string,\n  opts?: {\n    /**\n     * If `true`, clears the module cache before requiring the module.\n     */\n    clearCache?: true | undefined;\n  },\n) {\n  const require = createRequire(import.meta.url);\n  try {\n    if (opts && opts.clearCache === true) {\n      delete require.cache[require.resolve(file)];\n    }\n    return require(file);\n  } catch (err) {\n    return null;\n  }\n}\n\n/**\n * Executes a command and returns the `stdout` and `stderr` as strings.\n *\n * @param command - The command to execute.\n * @param size - The maximum buffer size in kilobytes (default: 500KB).\n * @returns A promise that resolves to an object containing the `stdout` and `stderr` strings.\n */\nexport async function exec(\n  command: string,\n  size = 500,\n): Promise<{ stdout: string; stderr: string }> {\n  return new Promise<{ stdout: string; stderr: string }>((fulfil, reject) => {\n    child_process.exec(\n      command,\n      { maxBuffer: 1024 * size },\n      (err, stdout, stderr) => {\n        if (err) {\n          reject(err);\n          return;\n        }\n\n        fulfil({ stdout, stderr });\n      },\n    );\n  }).catch(err => {\n    if (err.code === 'ERR_CHILD_PROCESS_STDIO_MAXBUFFER') {\n      return exec(command, size * 2);\n    }\n    return Promise.reject(err);\n  });\n}\n\n/**\n * Fetches a resource from the specified URL\n * and saves it to the destination path.\n * Optionally, a proxy URL can be provided to make the\n * request through a proxy server.\n *\n * @param url - The URL of the resource to fetch.\n * @param dest - The destination path to save the fetched resource.\n * @param proxy - Optional. The URL of the proxy server to use for the request.\n * @returns A promise that resolves when the resource is successfully fetched and saved, or rejects with an error.\n */\nexport async function fetch(url: string, dest: string, proxy?: string) {\n  return new Promise<void>((fulfil, reject) => {\n    const parsedUrl = new URL(url);\n    const options: https.RequestOptions = {\n      hostname: parsedUrl.hostname,\n      port: parsedUrl.port,\n      path: parsedUrl.pathname,\n      headers: {\n        Connection: 'close',\n      },\n    };\n    if (proxy) {\n      options.agent = new HttpsProxyAgent(proxy);\n    }\n\n    https\n      .get(options, response => {\n        const code = response.statusCode;\n        if (code == null) {\n          return reject(new Error('No status code'));\n        }\n        if (code >= 400) {\n          reject({ code, message: response.statusMessage });\n        } else if (code >= 300) {\n          if (response.headers.location == null) {\n            return reject(new Error('No location header'));\n          }\n          fetch(response.headers.location, dest, proxy).then(fulfil, reject);\n        } else {\n          response\n            .pipe(createWriteStream(dest))\n            .on('finish', () => fulfil())\n            .on('error', reject);\n        }\n      })\n      .on('error', reject);\n  });\n}\n\n/**\n * Stashes files from a directory to a temporary directory.\n *\n * @param dir - The source directory containing the files to be stashed.\n * @param dest - The destination directory where the stashed files will be stored.\n * @returns A promise that resolves when the stashing process is complete.\n */\nexport async function stashFiles(dir: string, dest: string) {\n  const tmpDir = path.join(dir, tmpDirName);\n  try {\n    await fs.rm(tmpDir, { recursive: true, force: true });\n  } catch (e) {\n    if (\n      !(e instanceof Error && 'errno' in e && 'syscall' in e && 'code' in e)\n    ) {\n      return;\n    }\n    if (e.errno !== -2 && e.syscall !== 'rmdir' && e.code !== 'ENOENT') {\n      throw e;\n    }\n  }\n  await fs.mkdir(tmpDir);\n  const files = await fs.readdir(dest, { recursive: true });\n  for (const file of files) {\n    const filePath = path.join(dest, file);\n    const targetPath = path.join(tmpDir, file);\n    const isDir = await isDirectory(filePath);\n    if (isDir) {\n      await fs.cp(filePath, targetPath, { recursive: true });\n    } else {\n      await fs.cp(filePath, targetPath);\n      await fs.unlink(filePath);\n    }\n  }\n}\n\n/**\n * Unstashes files from a temporary directory to a destination directory.\n *\n * @param dir - The directory where the temporary directory is located.\n * @param dest - The destination directory where the files will be unstashed.\n */\nexport async function unstashFiles(dir: string, dest: string) {\n  const tmpDir = path.join(dir, tmpDirName);\n  const files = await fs.readdir(tmpDir, { recursive: true });\n  for (const filename of files) {\n    const tmpFile = path.join(tmpDir, filename);\n    const targetPath = path.join(dest, filename);\n    const isDir = await isDirectory(tmpFile);\n    if (isDir) {\n      await fs.cp(tmpFile, targetPath, { recursive: true });\n    } else {\n      if (filename !== tigedConfigName) {\n        await fs.cp(tmpFile, targetPath);\n      }\n      await fs.unlink(tmpFile);\n    }\n  }\n  await fs.rm(tmpDir, { recursive: true, force: true });\n}\n\n/**\n * Asynchronously checks if a given file path exists.\n *\n * @param filePath - The path to the file or directory to check.\n * @returns A promise that resolves to `true` if the path exists, otherwise `false`.\n *\n * @example\n * <caption>#### Check if a file exists</caption>\n *\n * ```ts\n * const exists = await pathExists('/path/to/file');\n * console.log(exists); // true or false\n * ```\n */\nexport const pathExists = async (filePath: string): Promise<boolean> => {\n  try {\n    await fs.access(filePath);\n    return true;\n  } catch (err) {\n    return false;\n  }\n};\n\n/**\n * Asynchronously checks if a given file path is a directory.\n *\n * @param filePath - The path to the file or directory to check.\n * @returns A promise that resolves to `true` if the path is a directory, otherwise `false`.\n *\n * @example\n * <caption>#### Check if a path is a directory</caption>\n *\n * ```ts\n * const isDir = await isDirectory('/path/to/directory');\n * console.log(isDir); // true or false\n * ```\n */\nexport const isDirectory = async (filePath: string): Promise<boolean> => {\n  try {\n    const stats = await fs.lstat(filePath);\n    return stats.isDirectory();\n  } catch (err) {\n    return false;\n  }\n};\n\nexport const base = /* @__PURE__ */ path.join(homeOrTmp, '.degit');\n"],"mappings":"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","names":["fs","path","require","exec","picocolors","opts","exec"]}